% This is "sig-alternate.tex" V2.1 April 2013
% This file should be compiled with V2.5 of "sig-alternate.cls" May 2012
%
% This example file demonstrates the use of the 'sig-alternate.cls'
% V2.5 LaTeX2e document class file. It is for those submitting
% articles to ACM Conference Proceedings WHO DO NOT WISH TO
% STRICTLY ADHERE TO THE SIGS (PUBS-BOARD-ENDORSED) STYLE.
% The 'sig-alternate.cls' file will produce a similar-looking,
% albeit, 'tighter' paper resulting in, invariably, fewer pages.
%
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.5) produces:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) NO page numbers
%
% as against the acm_proc_article-sp.cls file which
% DOES NOT produce 1) thru' 3) above.
%
% Using 'sig-alternate.cls' you have control, however, from within
% the source .tex file, over both the CopyrightYear
% (defaulted to 200X) and the ACM Copyright Data
% (defaulted to X-XXXXX-XX-X/XX/XX).
% e.g.
% \CopyrightYear{2007} will cause 2007 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
% ---------------------------------------------------------------------------------------------------------------
% This .tex source is an example which *does* use
% the .bib file (from which the .bbl file % is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission, you *NEED* to 'insert'
% your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% ================= IF YOU HAVE QUESTIONS =======================
% Questions regarding the SIGS styles, SIGS policies and
% procedures, Conferences etc. should be sent to
% Adrienne Griscti (griscti@acm.org)
%
% Technical questions _only_ to
% Gerald Murray (murray@hq.acm.org)
% ===============================================================
%
% For tracking purposes - this is V2.0 - May 2012

\newif\ifdraft
\drafttrue
%\draftfalse


\documentclass{sig-alternate-05-2015}
\usepackage{url}
\usepackage{epsfig}
\usepackage{makeidx}         % allows index generation
\usepackage{graphicx}        % standard LaTeX graphics tool
                             % when including figure files
\usepackage{multicol}        % used for the two-column index
\usepackage[bottom]{footmisc}% places footnotes at page bottom
\usepackage{float}           % H para posicionar figuras
\usepackage{booktabs}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{xspace}


\input{macros}

\begin{document}

% Copyright
\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
\doi{10.475/123_4}

% ISBN
\isbn{123-4567-24-567/08/06}

%Conference
\conferenceinfo{ICSME '16}{Oct 02-10, 2016, Raleigh, North Carolina USA}

\acmPrice{\$15.00}

%
% --- Author Metadata here ---
\conferenceinfo{ICSME}{'16 Raleigh, North Carolina USA}
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{Who introduced this bug? \\ It may not have been caused by the previous commit!}
%\subtitle{[Extended Abstract]
%\titlenote{A full version of this paper is available as
%\textit{Author's Guide to Preparing ACM SIG Proceedings Using
%\LaTeX$2_\epsilon$\ and BibTeX} at
%\texttt{www.acm.org/eaddress.htm}}}
%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

\numberofauthors{3} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.

\author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
\alignauthor
Gema Rodr\'iguez-P\'erez\\
       \affaddr{GSyC/LibreSoft \\ Universidad Rey Juan Carlos}\\
       \affaddr{Madrid, Spain}\\
       \email{gerope@libresoft.es}
% 2nd. author
\alignauthor
Jesus M. Gonzalez-Barahona\\
      \affaddr{GSyC/LibreSoft \\ Universidad Rey Juan Carlos}\\
       \affaddr{Madrid, Spain}\\
       \email{jgb@gsyc.es}
% 3rd. author
\alignauthor Gregorio Robles\\
       \affaddr{GSyC/LibreSoft \\ Universidad Rey Juan Carlos}\\
       \affaddr{Madrid, Spain}\\
       \email{grex@gsyc.urjc.es}
\and  % use '\and' if you need 'another row' of author names
}
% There's nothing stopping you putting the seventh, eighth, etc.
% author on the opening page (as the 'third row') but we ask,
% for aesthetic reasons that you place these 'additional authors'
% in the \additional authors block, viz.
%\additionalauthors{Additional authors: John Smith (The Th{\o}rv{\"a}ld Group,
%email: {\texttt{jsmith@affiliation.org}}) and Julius P.~Kumquat
%(The Kumquat Consortium, email: {\texttt{jpkumquat@consortium.net}}).}
\date{8 April 2016}
% Just remember to make sure that the TOTAL number of authors
% is the number that will appear on the first page PLUS the
% number that will appear in the \additionalauthors section.

\maketitle
\begin{abstract}
  The assumption that ``a given bug was introduced by the lines of code that were modified to fix it'' seems at first glance very reasonable. In fact, many studies on bug fixing are built upon it. However, there is little empirical evidence supporting it, and a careful examination shows other possible sources for the introduction of bugs, such as an older modification, or a change in some API in a different part of the code.

This paper presents an observational study designed to shed some more light in this area. For that, we studied the lines changed by bug fixes as a part of ``the previous commit'' (or commits) in the OpenStack project. Using information from the code management, issue tracking, and code review systems, we analyzed if the code introduced by previous commits was correct at the time of introduction, and was therefore the cause of the bug. Our results show that the assumption that bugs were introduced in the previous commit does not hold for a large fraction (at least 37\%) of the analyzed bugs.
\end{abstract}


%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
%\begin{CCSXML}
%<ccs2012>
% <concept>
%  <concept_id>10010520.10010553.10010562</concept_id>
%  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
%  <concept_significance>500</concept_significance>
% </concept>
% <concept>
%  <concept_id>10010520.10010575.10010755</concept_id>
%  <concept_desc>Computer systems organization~Redundancy</concept_desc>
%  <concept_significance>300</concept_significance>
% </concept>
% <concept>
%  <concept_id>10010520.10010553.10010554</concept_id>
%  <concept_desc>Computer systems organization~Robotics</concept_desc>
%  <concept_significance>100</concept_significance>
% </concept>
% <concept>
%  <concept_id>10003033.10003083.10003095</concept_id>
%  <concept_desc>Networks~Network reliability</concept_desc>
%  <concept_significance>100</concept_significance>
% </concept>
%</ccs2012>
%\end{CCSXML}

%\ccsdesc[500]{Computer systems organization~Embedded systems}
%\ccsdesc[300]{Computer systems organization~Redundancy}
%\ccsdesc{Computer systems organization~Robotics}
%\ccsdesc[100]{Networks~Network reliability}


%
% End generated code
%

%
%  Use this command to print the description
%
%\printccsdesc

% We no longer use \terms command
%\terms{Theory}

\keywords{Bug introduction, bug seeding, SZZ algorithm, previous commit}

\section{Introduction}
\label{sec:introduction}

When a failure is found in some software, developers try to fix it by locating and modifying the source code line(s) that are the cause for the wrong behavior. It may seem reasonable to assume that previous modifications of these lines are the cause of the bug. Those previous modifications are what will refer through this paper as the \textit{previous commits}. 

However, to find where and when a bug was introduced in the source code is not a trivial task, and it may be much more complex than what this assumption suggests. This fact has been largely ignored in much of the bug-fix literature, mainly because the data related to the origin of a bug is \emph{embedded} in the evolution of the software~\cite{sinha2010buginnings}, as Sinha et al. state. With this they mean that there is no easy evidence (artifact, comment or log) where developers specify what produced that error from a more historical point of view. The explanation of the cause is thus \emph{embedded} in the project.

This is the reason why many studies in the area of software maintenance and evolution start with this implicit assumption. As an anecdotal evidence, we have found the following rationales in several research areas:

\begin{itemize}
  \item bug seeding studies, e.g., \textit{``This earlier change is the one that caused the later fixed''}~\cite{williams2008szz} or \textit{``The lines affected in the process of fixing a bug are the same one that originated or seeded that bug''}~\cite{izquierdo2011developers},
  \item bug fix patterns, e.g., \textit{``The version before the bug fix revision is the bug version''}~\cite{pan2009toward},
  \item defect prediction studies,  e.g., \textit{``A line that is deleted or changed by a bug-fixing change is a faulty line''}~\cite{altman1968financial},
  \item tools that prevent future bugs, e.g., \textit{``We assume that a change/commit is buggy if its modifications has been later altered by a bug-fix commit''}~\cite{fejzer2015supporting}. 
\end{itemize}

But although the assumption can be found frequently in the research literature, in our opinion there is not enough empirical evidence supporting it. That is the reason why we have conducted an observational study on bug fixing, devoting a significant effort to locate the origin of bugs in source code, and to understand the possible causes. Our main aim was to identify it the previous commit to to a bug fix was buggy ``at the time of committing it''. That is, if the program showed the bug at that moment because of the code introduced in that commit, or on the contrary, if the bug was caused by some earlier commit to that code, or by some other commit affecting other parts of the program.

To illustrate a case in which the assumption of the previous commit is fulfilled, Figure~\ref{fig:1} shows an example of what we understand as a previous commit causing a bug. Let's assume that we have three different versions of the same file in the history of the control version of the project:

\begin{figure*}[ht]
\centering
\includegraphics[height=2in,width=7.2in]{responsible.png}
\caption{Example of a change in which the bug was introduced in the previous commit. More recent versions of the code are on the left.}
\label{fig:1}       % Give a unique label
\end{figure*}


\begin{enumerate}
  \item The code on the left (subfigure \textit{(1)}) is the one after the bug was fixed.
  \item The code in the middle (subfigure \textit{(2)}) shows the previous version of the code (the previous commit), which was already causing malfunction.
  \item The code on the right (subfigure \textit{(3)}) shows the version of the file before the previous commit. In this case, at that point the bug did not exist.
\end{enumerate}

\begin{figure}[ht]
\centering
\includegraphics[height=2.4cm]{gerritPrevCommit.png}
\caption{Description of the bug-fix commit for a case in which the previous commit caused the bug.}
\label{fig:2}       % Give a unique label
\end{figure}

According to the description in the log of the commit that fixed the bug (see Figure~\ref{fig:2}), the previous commit introduced it: a string variable was produced instead of a Boolean variable, which was needed to satisfy expectations by the rest of the code.

For an example of the contrary, when the assumption is not fulfilled, consider Figure~\ref{fig:3}, which shows a case in which the code introduced by the previous commit was correct at the moment of introducing it. Now, the log of the commit fixing the bug (Figure~\ref{fig:4}) describes that the name of an argument had changed due to some other commit to other part of the software, causing the failure. In this case, the failure has nothing to do with the previous commit, but with later changes in other areas that were not properly reflected in this code. When the lines were introduced by the previous commit, they where not buggy.

\begin{figure*}[ht]
\centering
\includegraphics[height=2in,width=7.2in]{noResponsible.png}
\caption{Example of a change where the previous commit, 0dc91bed, did not insert the bug. More recent versions of the code are on the left.}
\label{fig:3}       % Give a unique label
\end{figure*}

\begin{figure}[ht]
\centering
\includegraphics[height=2.4cm]{UpdateFixBug.png}
\caption{Description of the bug-fix commit for a case in which the previous commit did not cause the bug.}
\label{fig:4}       % Give a unique label
\end{figure}

This is an example of how in projects that are evolving, code that at some point was correct could become buggy later. Changes in other parts of the code may trigger bugs in places which were correct in the past. This happens often in situations of changes in called APIs: when the code was written, it was correct, although later modifications to APIs had as a side effect that the formerly correct code started to show a wrong behavior, making the software fail. In such cases, the source of the error cannot be attributed to the changes performed in the previous commit, which were correct when they were introduced, since in that moment they referred to a different API.

The goal of this paper is to find out to which extent the cause of bugs can be attributed to the previous commit. We will consider that the previous commit is the cause for the bug if that code was buggy (caused the malfunction) in the context of the code at the moment it was introduced. If the code was right at that time, but the bug is due to some other change in the chain of previous commits, or to changes to other areas of the code (such as a change in APIs), we do not consider that change to be the cause of the bug.

More formally, we address the following research questions:

\begin{itemize}
     \item RQ1: How can we identify when changes to code do fix a bug?
     \item RQ2: How often is the previous commit the cause of a bug?
\end{itemize}

RQ2 is the main question that we want to answer: given bugs that have been fixed by changing some code, how many of those were introduced by the previous commit?

In practice, to answer RQ2 we first need to study the issue-tracking system and identify the subset of closed tickets that correspond to fixed bugs. In essence, RQ1 could be also stated as \emph{Which tickets in the issue tracking system are (real) bug reports?}, assuming that we can track tickets to changes in code. This is because (real) bugs are managed in an issue-tracking system together with feature requests, optimization, test cases, etc. As we are only interested in bugs, we need to first identify those as a previous step to analyze if they have been caused by the previous commit.

While RQ1 is instrumental, with RQ2 we address a very fundamental aspect of the studies on how bugs are fixed: the underlying assumption that the commit previous to a bug fix \emph{touched} the same lines introducing the bug. If evidence is found that in a large fraction of the cases the corresponding code was correct when it was introduced, there is no reason to blame it as the cause of the bug, even if changing it fixes the bug. Therefore, any result obtained after this assumption should be revisited with some care.

The remainder of this paper is structured as follows. Next, we present the current body of knowledge in Section~\ref{sec:related}. Section~\ref{sec:methodology} describes the methodology used to identify the moment in which the bug was introduced in the source code, followed by the results obtained after applying our approach to a selection of OpenStack bug fixes in Section~\ref{sec:results}. Section~\ref{sec:discussion} answers the research questions and discusses potential applications and improvements of our approach. After reporting the limitations and threats to validity in Section~\ref{sec:threats}, we draw some conclusions and point out some potential future work in Section~\ref{sec:conclusions}.


\section{Related Work}
\label{sec:related}

The study of code changes introducing bugs has been a \emph{hot} topic in the mining software repositories research community for over a decade. The most used algorithm to automatically identify them has been proposed by Sliwerski et al.~\cite{sliwerski2005changes}, which is an improvement to previous approaches~\cite{vcubranic2003hipikat,fischer2003analyzing,fischer2003populating}. Currently, it is a well-known algorithm, called SZZ, based on text differences to discover modified, added and deleted lines between the bug-fix and its previous version. The SZZ algorithm uses the CVS \texttt{annotate} command\footnote{Other versioning systems provide similar functionality to CVS \texttt{annotate}; for instance, git offers \texttt{blame}.} to identify the last commit that \emph{touched} these lines.

There are several research articles that suggest improvements to the SZZ algorithm. Kim et al.~\cite{kim2006automatic} use annotation graphs instead of CVS annotation to locate, in the previous versions, the lines affected by modification and deletion. Also, they avoid some false positives by not considering blank spaces, changes in the format or changes in the comments. Williams et al. have revisited the SZZ algorithm to track fix-inducing changes and identify types of changes~\cite{williams2008szz}. 
\gema{mirar como se nombra en[20] porque uno de los revisores nos dijo : "Shouldn't 1(2) be named 'Bug-inducing' instead of 'Fix-inducing'?"}\gema{He mirado como se nombra el ariticulo y es fix-inducing no bug-inducing. }


The SZZ algorithm (and its \emph{successors}) have had a considerable impact in the research community. Noteworthy is the fact that the paper with original the SZZ algorithm~\cite{sliwerski2005changes} has been cited, according to Google Scholar, 475 times as of April 
2016. The enhanced version of the SZZ algorithm~\cite{kim2006automatic} counts with 123 citations. Hence, there is a myriad of articles that use SZZ on an ample number of scenarios. Without trying to be exhaustive, we offer several examples. Therefore, Yang et al. apply SZZ to find what kind of bug-inducing changes are likely to become a great threat after being marked as bug-fix changes~\cite{yangbug}. Zimmermann et al. use it for predicting bugs in large software systems~\cite{zimmermann2007predicting}. Kim et al. show how to classify file changes as buggy or clean using change information features and source code terms~\cite{kim2008classifying}. Kamei et al. apply it to validate effort-aware bug-prediction models~\cite{kamei2010revisiting}. Eyolfson use it to study if time of the day and developer experience affect the probability of a commit to introduce a bug~\cite{eyolfson2011time}. Izquierdo et al. use the SZZ algorithm to see if developers are fixing their own bugs~\cite{izquierdo2011developers}. Yin et al. use SZZ to find how many fixes to bugs introduce new bugs~\cite{yin2011fixes}. Tantithamthavorn et al. employ it to quickly identify the location of a bug~\cite{tantithamthavorn2013mining}. Fejzer et al. use it to support code review~\cite{fejzer2015supporting}. Altman et al. use it to predict whether a change is buggy at the time of a commit, evaluating the change classification techniques to address the incorrect evaluation presented by cross-validation~\cite{altman1968financial}. Asaduzzaman et al. apply the SZZ algorithm on Android to study its maintainability~\cite{asaduzzaman2012bug}.

%\grex{maybe talk about my paper with dmg and ahmed, where bugs could be found elsewhere~\cite{german2009change}. There the talk is precisely about those bugs whose origina are elsewhere. Title of the paper: \emph{Change impact graphs: Determining the impact of prior codechanges}}

Prechelt and Pepper offer a good overview of the limitations of bug-introducing code changes when adopted by practitioners. They point out that one of the obstacles in the way of a reliable analysis are the ``additional changes between defect insertion time and defect correction time that happen to happen at subsequently defect-corrected locations''~\cite{prechelt2014software}. Some methods that consider sources of information other than the previous commit have been proposed already; so, German et al.~\cite{german2009change} 
point out that software is in constant change, and that changes performed may have impact across the whole system and may lead to the manifestation of bugs in unchanged parts. In this case, a bug emerges in a different location from the source of the bug, which is a change to a function somewhere else in the source code base. 

Kamei et al.
%used the 'Just-in Time Quality Assurance' concept, which focuses on identifying defect-prone at the level of software changes/patches instead of files or packages and allowing developers to review these risky changes while they are still fresh in their minds. In the paper, they 
present a change risk model in which several characteristics of a software change are considered (lines added, developer experience...) and empirically evaluate their approach to identify in real-time those software changes that could become a defect~\cite{kamei2013large}. Altman et al. use the same concept to study where authors that applied change classification on a proprietary code base, sharing the experience and lessons learned. They concluded that interpretable prediction models are needed for software defect prediction~\cite{altman1968financial}. 

Sinha et al. present another technique to identify the origins of a bug in~\cite{sinha2010buginnings}. Their technique is not a text-based technique like the SZZ algorithm, as the authors analyze the effects of bug-fix changes on program dependencies. So, taking into account the semantics of the source code they achieved higher accuracy in identifying the origins of a bug. The two approaches have however some methodological patterns in common:

\begin{enumerate}
  \item They find the differences between the bug-fix version and the previous version of the file to recognize those changes done by the bug-fix commit. 
  \item They look back in the code revision history until they identify which version touched the lines affected in the bug-fix for the last time.
\end{enumerate}


On the other hand, the question of whether a bug report is really a bug or not has been widely studied in the software maintenance and evolution research literature in the last years. In this sense, Pan et al. classify the different types of bug-fix patterns that exist most commonly~\cite{pan2009toward}. Antoniol et al. have used a text-based approach to classify bug reports into corrective maintenance and other kinds of activities~\cite{antoniol2008bug}. Herzig et al. have done a manual examination of thousands of bug reports and have found that around a third of them are misclassified, in the sense that they were not a bug report but a feature request, an internal refactoring or an update to documentation~\cite{herzig2013s}. They show that almost 40\% of the files marked as defective did not have a bug, and suggest that this missclassification introduces bias in bug prediction models and tools. Tantithamthavorn et al. investigated the nature of mislabeled issue reports and how they impact in the prediction models~\cite{tantithamthavorn2015impact}.
%, achieving that the mislabeling presented in the issue reports is not random. Furthermore, after training some models with clean and noise data, they obtained the same accuracy in the results 


 
%\gema{A brief summary about "A Large-Scale Empirical Study of Just-in-Time Quality Assurance": In this paper the concept of 'Just-in Time Quality Assurance' is presented, this concept focus in identifying defect-prone at level of software changes/patches instead of files or packages, this way the developers can review these risky changes while they are still fresh in their minds. In the paper they present as change risk model in which several characteristics of a software changes are implemented(lines added, developer experience...) They want provide an effort-reducing way to focus on the most risky changes, they empirically evaluated their approach in "Just-In-Time Quality Assurance" to identify in real time software changes that would be a defect}

 
%\gema{A brief summary about "The Impact of Mislabelling on the Performance and Interpretation of Defect Prediction Models", \cite{tantithamthavorn2015impact}: In the paper the authors carried out a study where investigated the nature of mislabelled issue reports and also how this mislabelled impact in the prediction models. Finding that the mislabelling is not random. Furthermore the models trained using data noise are often just as accurate as the ones trained with clear data, but using clear data will likely allow the models to identify more of the truly defective modules. }
 
%\gema{A brief summary about "Online Defect Prediction for Imbalanced Data",\cite{altman1968financial}: A change classification can predict whether a change is buggy at the time of the commit, which allow to developers to act on the prediction results as soon as a commit is made, the benefit is that reviewers have less code to examine to identify defect, but the problem is that for the same reason is more difficult to predict on changes accurately. The authors applied change classification on a proprietary code case and share the experience and lesson learned. They evaluated the change classification techniques to address the incorrect evaluation presented by cross-validation, and applied some techniques improving the precision, they conclude that interpretable prediction models  are needed for software defect prediction, They used the SZZ approach saying that 'A line that is deleted or changed by a bug-fixing change is a faulty line'}

\section{Methodology}
\label{sec:methodology}

In the case of OpenStack, the data needed to analyze when a bug was introduced can be obtained from the source code management, issue tracking, and code review systems, as in many other free/open source software (FOSS) projects. In our analysis, we have focused on Git\footnote{\url{https://git-scm.com/}} as source code management, Launchpad\footnote{\url{https://launchpad.net/}} as issue tracking system, and Gerrit\footnote{\url{https://www.gerritcodereview.com/}} as code review supporting tool, as those are the one used by OpenStack, but our methodology should be adaptable to any other similar tools.

Launchpad works with issue reports called tickets, which describe bug reports, feature requests, maintenance tickets, and even design discussions. In our study, however, we are only interested in those tickets that have following properties:

\begin{enumerate}
  \item They describe a bug report, and
  \item They have been closed and merged in the code source to fix the described bug.
\end{enumerate}

In these bug reports we can find a comment with the link to Gerrit where the bug was fixed. It is in Gerrit where we can see all the patchsets proposed and the comments done by the reviewers. 

\subsection{First Stage: Filtering}
\label{sec:firstStage}

First, we have to identify what issues found in Launchpad are bug reports. This is not a trivial task and is labor intensive as it has to be done manually. As the process is repetitive, we developed a web-based tool\footnote{\url{bugtracking.libresoft.es}} that helps in the classification process. This tool offers all relevant information required to decide if an issue corresponds to a bug report or not. The tool uses information extracted automatically from the project repositories, and offers a web-based interface which allows for collaboration, traceability and transparency in the identification of bug reports.

During the identification of the issues, we have to take into account the following parameters for each ticket:

\begin{itemize}
  \item The title of the issue report
  \item The description of the issue report
  \item The description of the fix commit
  \item And sometimes the changes to the source code, when neither the description nor the comments by developers and reviewers in Launchpad and Gerrit clarified the underlying ticket.
\end{itemize}

A screenshot of the web interface of the tool is shown in Figure~\ref{fig:screenshot}. The left side is used to display the information extracted from Launchpad and Gerrit; on the right researchers can write and classify the ticket into one of the three groups. Additional meta-data, such as keywords, comments and the reviewer are included in the database.

\begin{figure}[ht]
\centering
\includegraphics[height=12cm]{index.png}
\caption{Screenshot of the tool used to classify the tickets.}
\label{fig:screenshot}       % Give a unique label
\end{figure}

Each ticket was categorized into one of following three groups:

\begin{enumerate}
  \item Group 1 (\textit{Bug Report}): The ticket describes a bug report.
  \item Group 2 (\textit{Not Bug Report}): The ticket describes a feature, an optimization code, changes in test files or other situations, but not bug reports.
  \item Group 3 (\textit{Undecided}): The ticket presents a vague description and cannot be classified without doubts.
\end{enumerate}

From the experience of analyzing a small number of tickets, we agreed on following four criteria: 
\begin{enumerate}

    \item Each time the title or the description of a ticket describes an unexpected behavior in the program, it was considered as a bug report. 
    \item If the description of the ticket presents an optimization, deletion of a dead code or the implementation of new characteristics, we agreed not to classify it as a bug report because there is no failure. 
    \item When the ticket described that some updates in the code were required, such as updates in the OS \grex{what is a SO?} \gema{queria poner en el Sistema Operativo pero se me coló el español...}or in a version of a package/module which is being used in the code, the ticket is a bug report. We consider all tickets that require updating as bug reports, because updating a software hints to the software not operating as expected. \gema{Esto es lo que dijo uno de los revisores sobre este parrafo : "First, the rule is unclear for me. Do you mean an update to the ticket? The code? The review? Second, the rationale is unclear and unsupported. Why would such an update indicate that a bug was present?" Deberíamos modificarlo}
    \item When only test files are affected by a ticket, it is not a bug report. We consider bug errors in test files to be of a different type, as the software may still work as expected.
    
\end{enumerate}

Sometimes we have been unable to classify a bug report because we did not have sufficient data or because of the complexity of the issue. In those cases, tickets have been classified into the \textit{Undecided} group.

\subsection{Second Stage: Who caused the Bug?}
\label{sec:secondStage}

In this second part, our work was focused on analyzing the previous commit exclusively for those tickets classified in the \textit{Bug Report} group. Therefore we had to locate the line that contained the bug, inquire the reason of the software failure, and sometimes gather additional information from the context of the bug and the project.

For that, we had to analyze the lines involved in the bug fix and in the \emph{parent} commit of the bug fix commit, being sure that the lines were added, inserted or modified in the previous commit. We refer to \emph{parent} commit as the commit that modified any line of code in the file before the fix-bug commit, in contrast to the \emph{previous} commit where the modified lines were the same than in the fix-bug commit. It should be noted that those lines modified in the parent commit do not have to be the ones that have been modified in the bug-fix.
Figure~\ref{fig:parentgerrit} contains a snapshot of the information provided by Gerrit, where the link to the parent commit(s) can be found, that corresponds to the bug-fix shown in~\ref{fig:1}. As can be seen, the previous commit (\textit{31f08423}) in Figure~\ref{fig:1} is different from the parent commit displayed in Figure~\ref{fig:parentgerrit} (\textit{db7fc59ebc}).


We do this process to be sure that we are looking at the correct change, because sometimes, although the commit added many lines, the code before the commit contained some of the lines added; and such cases, we have false positives where the previous commit did not cause the bug. 


%\grex{Gema, puedes aclarar este parrafo? Que es el "parent" commit? Es lo mismo que el previous commit? Es la primera vez que hablamos de el. Quizas sea buena idea que lo reformules en castellano, porque ahora mismo es criptico}\gema{el parent commit es el ultimo commit que se hizo en el fichero antes de que se realizase el que arreglo el error, por tanto lo que hago usar diff y blame en el commit parent y en el commit que arregla el error para saber que lineas se han cambiado y que commit las cambio), y despues hago lo mismo con el commit previo y el commit parent del previo para saber que en realidad en ese momento se produjo el cambio. En el gerrit nos dan esa info como se puede ver en la figura}

%\grex{Sigue sin quedarme clara cual es la relacion entre el parent commit y el previous commit (mira que yo pensaba que eran lo mismo)... podriamos dar una definicion?}  
%\gema{EL parent commit es el ultimo commit que toco alguna linea del fichero antes de que se realizase el fix bug commit, pero las lineas que toco el commit parent no tienen porque contener ningun bug. Mientras que el commit previo es la ultima modificacion que se hizo en aquellas lineas que ha tocado el bug-fix.Estaría bien dar una definicion por si no se ve claro}

\begin{figure}[ht]
\centering
\includegraphics[height=1.9cm]{parent.png}
\caption{Information about the bug as displayed by Gerrit.}
\label{fig:parentgerrit}       % Give a unique label
\end{figure}


The analysis was done manually. We used \textit{git blame} to see the previous commit for each line of the involved file. Also, we used \textit{diff} to see the differences between the two files, in our case as the file is going to be the same, between the file in two different moments in the control version system.

The procedure for each file involved in a bug fix is as follows:

\begin{enumerate}
  \item git checkout \textit{commit that fixed the bug}, git blame \textit{file involved}. In this step we can see the lines added, modified or deleted by the commit that fixed the bug.
  \item git checkout \textit{parent of commit that fixes the bug}, git blame \textit{file involved}. In this step we can see the previous commits for the different lines \emph{touched} in the fixed bug.
  \item git checkout \textit{parent of previous commit}, git blame \textit{file involved}. With this step we can ensure that the previous commit introduced these lines.
\end{enumerate}

Finally we had to discard some \emph{noise} present in our results. This happened when the changes in the previous commit could not have caused the bug. Therefore, we deleted the previous commits for which the following criteria were met:

\begin{itemize}
    \item Exclusively blank lines
    \item Changes in the format
    \item Copied lines
    \item Changes in source code comments
    \item Updates in the version number of a file/software 
    \item Commits that were committed after the bug report was opened in Launchpad, according to \'Sliwerski et al.~\cite{sliwerski2005changes}.
\end{itemize}


\section{Evaluation}
\label{sec:evaluation}

We have validated our methodology analyzing tickets from OpenStack. OpenStack is a cloud computing platform with a huge developing community (more than 5,000 developers) and significant industrial support from several major companies such as Red Hat, Intel, IBM, HP, etc. OpenStack was particularly of interest because it is continuously evolving due to its very active community. Currently it has more than 233,000 commits with more than 2 million lines of code\footnote{\url{http://activity.openstack.org/dash/browser/}}. All its history is saved and available in a version control system\footnote{\url{https://wiki.openstack.org/wiki/Getting_The_Code}}, as well as its issue tracking system (Launchpad\footnote{\url{https://launchpad.net/openstack}}) and the source code review system (Gerrit\footnote{\url{https://review.openstack.org/}}).

OpenStack is composed of 9 projects, but we only focused on the main four: Nova, Cinder, Neutron and Horizon. As can be seen in Table~\ref{tab:OpenStack}, these projects have been very active during their entire history, and in the last year.

\begin{table}[htb]
\centering
%\begin{center} {\footnotesize
\begin{tabular}{lrr}
\toprule[0.3mm]%{\smallskip}
  & All History  & Last Year (2015) \\\hline
Nova    \kern 1pc & 14,558 & 3,283 \\
Fuel    \kern 1pc & 9,139 & 5,123 \\
Neutron  \kern 1pc & 8,452 & 3,855 \\
Horizon \kern 1pc & 4,871 & 1,994 \\
Cinder  \kern 1pc & 4,556 & 1,832 \\
Keystone\kern 1pc & 4,874 & 1,795  \\
Heat    \kern 1pc & 6,395 & 2,372  \\
Glance  \kern 1pc & 2,651 & 723 \\
Tempest \kern 1pc & 4,141 & 1,312 \\
\bottomrule[0.3mm]
\end{tabular} %}
\caption{ Commits per Project in OpenStack}
\label{tab:OpenStack}

%\end{center}
\end{table}

For these four projects we analyzed if bug fixes where introduce in their previous commits. For the first stage, we used the tool described in~\ref{sec:firstStage}. Three different researchers, were involved in this stage, resulting that each ticket was analyzed by two of the researchers independently. The second stage was done manually by the first author. %that, we extract a total of 459 tickets from this projects, in which we should be sure that the bug fixes come from a bug report, because two of five issues are misclassified \cite{herzig2013s} and this should cause bias in our final results.


\gema{En el primer estudio realizado por Andrea y por mi con en análisis de 100 tickets; en la primera fase obtuvimos un porcentaje de acuerdo del 83\% incrementándolo hasta un 94\% tras una discusión entre ambas. En cuanto a la segunda fase, obtuvimos un 74\% de similitud entre su análisis y el mio. Después de una revisión conjunta, incrementamos ese porcentaje hasta el 90\%. En este estudio la clasificaión de la segunda fase salió (53\% ,35\% y 11\%) pero no habíamos quitado los falsos positivos.}

%- It is unclear if the first stage (classifying the tickets) was done by two or three researchers. In Section 4 it is said to be two, as in Section 5.1 (they analyzed 459 tickets, so 917 reviews in total). However, Table 2 shows results for three researchers. In that case (3 researchers), it is unclear how issues were handled when they were two researchers in agreement and one in disagreement. Even if it is a subjective task, having the first stage (classification) with more than one researcher and the concordances help. While the numbers of Table 2 suggest that 3 different researchers worked on the task but each issue was evaluated by only two of the three developers, this is never mentioned on the paper.


\section{Results}
\label{sec:results}

A total of 459 different tickets from the Launchpad of the four main projects in OpenStack: 125 tickets from Nova, 125 tickets from cinder, 125 tickets from Horizon and 84 tickets from Neutron.

\subsection{First Stage}
\label{sec:resultsFS}

We classify a total of 459 tickets using the tool, resulting in 917 reviews\footnote{One review was discarded as it was left empty.}. Only those tickets classified as bug reports  with a percentage of agreement of 100\% by both researchers were considered in the next stage, which analyzes if the cause of the bug was introduced in their previous commits. Thus, to measure agreement among researchers in the context of a content analysis, we have used the percent agreement variable~\cite{neuendorf2002content}. This process requires manual inspection by researchers. In the mean, classifying a ticket takes around 5 minutes, although the amount of time decreases with experience as could be expected. We have measured in Github the mean spends analyzing a ticket per each researcher, obtaining in the best case 3.35 minutes while 4.09 and 4.12 for the other two. Whereas analyzing who caused the bug, in mean, takes around 16 minutes per bug report. 
 
\gema{He calculado el tiempo medio que cada investigador (Nelson, Dorealda y Yo) ha invertido en el análisis de los tickets en
 la primera fase, usando la herrramienta. Siguiendo el orden: (4.09, 3.35, 4.12)}
\gema{He calculado la media, en minutos, del tiempo empleado en encontrar la causa del bug en cada ticket. La media a sido alrededor de 16 minutos.}


\begin{table*}
\centering
%\begin{center} {\footnotesize
\begin{tabular}{l|rrr|r}
\toprule[0.3mm]%{\smallskip}
  & Bug Report & Not Bug Report & Undecided & Total \\\hline
R1  & (184) 55\% & (115) 34\% & (35) 11\% & 334 (100\%) \\
R2  & (188) 76\% & (54) 22\% & (7) ~3\% & 249 (100\%) \\
R3 & (188) 56\% & (116) 35\% & (30) ~9\% & 334 (100\%) \\ \hline
Agree & (209) 72\% & (74) 25\% & (9) ~3\% & 292 (100\%) \\
\bottomrule[0.3mm]
\end{tabular} %}
\caption{Statistics for each researcher as a result of the classification process. For each researcher R, the number of tickets (and percentages) classified into the three groups is given. The \emph{Agree} row gives the number of tickets (and percentages) where two researchers agreed.}
\label{tab:2}
%\end{center}
\end{table*}


Table~\ref{tab:2} shows the classification percentages of the analyzed tickets for each researcher, and the number of tickets classified into the same group by two different researchers. %Obtaining that the researchers R1 and R2 had a similar data in their results, whereas research R2 got results significantly different with a higher number of tickets classified as Bug Report.
As a result, researchers identified 292 tickets in the same group, that is, their results matched in over 70\% of the cases. Of those, 209 tickets had been classified in the \emph{Bug report} group, 74 in the \emph{Not Bug Report} group, and 9 tickets classified in the \emph{Undecided} group.

We also measured the concordance in the classification of each developer according to the project analyzed (see table~\ref{tab:3}). Values obtained by the three researchers are very similar, in general around a 70\%. The concordance values were always above 60\%. 

\begin{table*}[htb]
\begin{center} {\footnotesize
\begin{tabular}{l|rrrr|r}
\toprule[0.3mm]%{\smallskip}
  & Nova & Cinder & Horizon & Neutron & Total\\\hline
R1 -- R2   & (44) 70\% & (40) ~77\%  & (37) 60\% & -        & (121) 68\% \\
R1 -- R3   &  -        & (46) ~73\%  & (48) 76\% & (26) 62\% & (120) 71\% \\
R2 -- R3   & (41) 66\% & (10) 100\% & -         & -        &  (51) 71\% \\
\bottomrule[0.3mm]
\end{tabular} }
\caption{Concordance among researchers for each repository.}
\label{tab:3}
\end{center}
\end{table*}


%After this, we can answer the first research question because at this moment we have all the data necessary and all the knowledge to can distinguish bug reports from others reports.

\vspace{0.2cm}
\fbox{\begin{minipage}{25em}
\textbf{RQ1: Using all the information available in the bug tracking system and code review systems related to a bug-fix, we have obtained that in at least 72\% of the tickets analyzed the bug-fixes were real bug reports.} 
\end{minipage}}
\vspace{0.1cm}


\subsection{Second Stage}
\label{sec:resultsSS}

In this stage we have analyzed the 209 tickets, the possible outcome of the analysis was one of the following three options:

\begin{itemize}
  \item Cause
  \item No Cause
  \item Undecided
\end{itemize}

This analysis takes into account that the bug could span many lines that may belong to several previous commits, but in fact, not all of them may have caused the bug. It may happen that in the previous commit lines may have been copied from further previous commits, comments may have been modified, or blank spaces/lines may have been introduced. Hence, the cause could be found in a single previous commit, in many or even in none. 

Figure~\ref{fig:manyprevious} contains a real example of a previous commit where more than one commit has been identified. In this case, we have two possible commits: \textit{e7be0a988} and \textit{e5296c1da}. Previous commit \textit{e7be0a988} did not cause the bug, because the modification affects only the version number of the software. It is previous commit \textit{e5296c1da} the one that caused the bug, because it introduced an incorrect \texttt{break} line. %\grex{Todavia no esta del todo claro... yo creo que esto merece un ejemplo - incluso con codigo real, tal y como hemos hecho al principio del articulo. Ademas, nos lo podemos permitir; tenemos espacio.}\gema{perfecto, ahora busco un ejemplo y lo anado abajo}

%\grex{No estan mal las descripciones superiores en la figura~\ref{fig:manyprevious} que dice ``After Fix Bug'' y ``Fix-inducing (Before fix bug)''?}
%\gema{creo que no, la de la izquierda es despues de que se arreglara el error, y la de la derecha es en el momento en que se introdujo el error}

\begin{figure*}[ht]
\centering
\includegraphics[height=4.9cm,width=7.2in]{manyprevious.png}
\caption{Example of previous commit where more than one commit has been identified. On the left in subfigure (1), the file after the bug-fixing commit. Previous commit \textit{e5296c1da} (subfigure (2)) is the cause of the bug in line 2422 with the presence of an incorrect \texttt{break} statement. 
Previous commits \textit{e7be0a988} (subfigure (3)) has also been identified; however, as it just changes the version number (line 218), it can be classified as not causing the bug.}
\label{fig:manyprevious}       % Give a unique label
\end{figure*}

We have identified a total of 462 previous commits which could be the cause of the 209 bug reports under analysis. Then, we analyzed the bug reports together with their previous commits discarding the cases where the previous commit was a false positive (\emph{noise}) such as blank lines, changes in comments, commits added previously date of bug report or even a change in the version of the file. Therefore, in total we have analyzed 349 previous commits.

As can be seen in Table~\ref{tab:responsability}, from the 349 previous commits, 179 have been considered to be the cause of the bug, whereas 129 have been identified as not being the cause.

We have been unable to decide in 39 cases. Figure~8 %\ref{fig:added}
 provides an example of such a situation; the file content after the bug fix can be seen on the left in subfigure (1) and the file before the fix commit on the right in subfigure (2); as it can be observed, the only difference is lines that have been added. Figure~9 %\ref{fig:unknow}
 offers an example of a different situation, where the researchers have not been able to classify the bug due to not having sufficient knowledge of the change, the context and the project. In both cases, we have not been able to know which previous commit could be the cause of the bug, so we classified them as \textit{Undecided}.

\begin{figure*}[ht]
\centering
\includegraphics[height=4.7cm, width=13cm]{addedlines.png}
\label{fig:added}       % Give a unique label
\caption{Example of scenario where the bug fix is composed only of lines added. The fix bug commit with lines added in green can be seen on the left (subfigure (1)), and the file as it was before the fix bug commit on the right (subfigure (2)).}
%52919
\end{figure*}

\begin{figure*}[ht]
\centering
\includegraphics[height=7.8cm]{unknowleadge.png}
\label{fig:unknow}       % Give a unique label
\caption{Example of previous commit where we have been unable to decide which line contains the bug. The left code snippet contains the code after the bug fix; the right code snippet shows the code before the bug fix.}
\end{figure*}


\begin{table}[htb]
\begin{center}
\begin{tabular}{lrr}
\toprule[0.3mm]
 & After Deleting Noise \\\hline
{Cause}  & (179) 51\% \\[0ex]
{Not Cause} & (129) 37\% \\[0ex]
{Undecided} & (41) 12\% \\[0ex]
\bottomrule[0.3mm]
\end{tabular}
\caption{Number of times (and percentage) where the previous commit is the cause, not the cause or could not be classified, after deleting noise.}
\label{tab:responsability}
\end{center}
\end{table}

%\begin{table}[htb]
%\begin{center}
%\begin{tabular}{lrr}
%\toprule[0.3mm]
%  & \multicolumn{1}{c}{Before} & \multicolumn{1}{c}{After} \\
%  & \multicolumn{1}{c}{Deleting Noise} & \multicolumn{1}{c}{Deleting Noise} \\\hline
%{Cause} & (152) 44\% & (152) 49\% \\[0ex]
%{Not Cause} & (154) 44\% & (114) 37\% \\[0ex]
%{Undecided} & (42) 12\% & (42) 14\% \\[0ex]
%\bottomrule[0.3mm]
%\end{tabular}
%\caption{Number of times (and percentage) where the previous commit is the cause, not the cause or could not be classified, before and after deleting noise.}
%\label{tab:responsability}
%\end{center}
%\end{table}3


If we attend to how many previous commits each of the 209 bug reports analyzed had, we see that 146 only had a previous commit as in Figure~\ref{fig:3}, whereas 63 had more than one previous commit as the one in Figure~\ref{fig:manyprevious}. In Table~\ref{tab:secondStage}, from the 146 unique previous commits, 77 were the cause of the bug, while 30 did not cause the failure and 39 we didn't know the cause. For the 63 bug reports that had more than one previous commit, a total number of 203 previous commits were identified; of them 102 were the cause of the bug, while 99 were not and 2 we were unable to decide. 
%\grex{No me queda claro que quieres decir con mas de un identificador previo}\gema{supongo que despues de ver el ejemplo se entienda mejor, identificador previo se refiere a que  al arreglar el error se shan tocado varias lineas que han sido anadidas o modificadas en commit diferentes, por tanto tenemos mas de un commit diferente, aqui use identificador en vez de commit y puede ser un error}

%\grex{Para los 58 bugs que tenian mas de un identificador previo hay 179 commits. Bien. Dices que 86 causaron el bug, 82 no y en 11 no se ha podido determinar. Lo que no veo es por que no agruampos estos datos segun los 58 bugs}\gema{Esos datos estan agrupados en la tabla 7, el fin de esta tabla era mostrar que cuando hay un solo comit previo el numero de no causantes del error es menor que cuando hay mas de un commit previo}

% Furthermore, focusing on how many previous commits presented each Bug Report, we obtained that 131 had one previous commit implicated, whereas 58 had more than one previous commit implicated in their file/s. According to Table \ref{tab:secondStage}, from the 131, we obtained that 65 of them inserted the bug, but 30 of them were not responsible in the failure of the system. And from the 58 which had more than one previous commits, we obtained in total 189 previous commit, where 86 of them were responsible and 82 were not responsible. %Probably, the bug was inserted in different lines of different commits, but not everyone has to be responsible for the commit, sometimes the previous commit copied lines from its previous commit or inserted comments and blank spaces. After the analysis the responsible can be only one of them, more than one or maybe none. 

\begin{table}[htb]
\begin{center} {\footnotesize
\begin{tabular}{lcc}
\toprule[0.3mm]
  & \multicolumn{1}{c}{One previous } & \multicolumn{1}{c}{More than one previous} \\
  & \multicolumn{1}{c}{commit} & \multicolumn{1}{c}{commit} \\\hline
\raisebox{1ex}{Cause}     & (65) 50\% & (86) 48\% \\[0ex]
\raisebox{1ex}{Not cause} & (30) 23\% & (82) 46\% \\[0ex]
\raisebox{1ex}{Undecided} & (36) 27\% & (11) ~6\% \\[0ex]
\bottomrule[0.3mm]
\end{tabular} }
\caption{Probability of being the cause of a bug depending on if just one previous commit or more than one previous commits are identified.}
\label{tab:secondStage}
\end{center}
\end{table}


%\gema{Los resultados que he obtenido y que queria plasmar en las tablas son:}
%\gema{- He analizado 189 bugs reports}\\
%\gema{- De los 189, 131 presentaban el mismo identificador de commit previo para todas las lineas que habian sido modificadas, mientras que 58 presentaban mas de un identificador de commit previo.}\\
%\gema{- Dentro de los bugs reports que tienen mas de un commit previo analizando el total de todos los commits para saber quien causo el bug, he encontrado que en total de los 179 comit previos 86 causaron el bug mientarsa que 82 no lo causaron y 11 no he podido decidir si eran causantes o no.}\\
%\gema{- Ademas he mirado como se distribuyen los commits en cada bug report dentro de cada proyecto analizado, y he visto que por ejemplo Neutron presentaba 11 bugs report con solo un ticket previo, 3 bugs report con dos identificadores diferentes para los commit previos, 2 bug reports que presentaban  3 commit previos... etc.}\\
%\gema{- Finalmente realice otra clasificacion en la que tenia en cuenta el numero de commits que fueron causantes del error para un mismo bug report. Al analizar los bug reports encontre que en aquellos que presenstaban mas de un commit previo no todos los commit eran causantes del error, y en ocasiones solamente habia un commit que causo el error y los otros no o por el contrario habia bugs report en los que ninguno de sus commits previos era responsable y otras ocasiones en las que todos los commits previos eran responsables. Por tanto la tabla 7 muestra cual es la responsabilidad (tods responsables, al menos uno ningun responsable y desconozco la responsabilidad) de los coommits previos presentes en un bug report. Por ejemplo, bugs reports que tenian dos commits previos, en 4 de ellos los dos commits previous eran responsables, mientras que en 9 bug report habia al menos un responsable y en otros 4 bug report ninguno de los dos commit previos eran responsables.}  

We also studied the distribution of the number of previous commits for each bug. This result will provide further insight into the bug-seeding nature; it offers as well an idea of the complexity of identifying the cause of a bug, as the more commits involved, the harder it is to identify the cause and understand it. As shown in Table~\ref{tab:secondStage2}, usually the number of commits that can be considered as previous is 1 (over 69\% of the cases), followed by 2 commits (13\%). In around 17\% of the cases, 3 or more commits are involved.

% the number of commits that can be considered as previous is 1, followed by 2 commits. \grex{the number of commits that can be considered as previous is 1, followed by 2 commits. No se que queremos decir} \grex{Tenemos que responder a estas dos preguntas todavia: Por que es interesante hacer lo que se comenta en este parrafo? Que utilidad tiene?}\gema{Creo que era interesante saber como se distribuyen los causantes de los bugs en cada projecto y cuantos commits previos presentan los bugs report en cada projecto analizado, ademas cuantos mas commits previos, en ocasiones, es muy dificil saber quien es el responsable por tanto pense que podria haber algun patron en relacion con el numero de commits previos y cuantos de ellos son responsables, pero parece que esto no ocurre con la muestra que hemos analizado.}

\begin{table*}[htb]
\begin{center} {\footnotesize
\begin{tabular}{lccccc}
\toprule[0.3mm]
  & \multicolumn{1}{c}{One previous} & \multicolumn{1}{c}{two previous} & \multicolumn{1}{c}{three previous} & \multicolumn{1}{c}{four previous} & \multicolumn{1}{c}{+five previous}\\
  & \multicolumn{1}{c}{commit} & \multicolumn{1}{c}{commits} & \multicolumn{1}{c}{commits}& \multicolumn{1}{c}{commits}& \multicolumn{1}{c}{commits}\\\hline
\raisebox{1ex}{Neutron} & 13  & 5 & 2 & 0 & 1 \\[0ex]
\raisebox{1ex}{Horizon} & 38  & 9 & 3 & 0 & 4 \\[0ex]
\raisebox{1ex}{Nova}    & 48  & 8 & 2 & 4 & 5 \\[0ex]
\raisebox{1ex}{Cinder}  & 47  & 6 & 8 & 3 & 3\\[0ex]
\raisebox{1ex}{Total}   & 146 & 28 & 15 & 7 & 13\\[0ex]
\bottomrule[0.3mm]
\end{tabular} }
\caption{ Distribution of the number of commits that can be considered as the previous commit per bug report for each project.}
\label{tab:secondStage2}
\end{center}
\end{table*}

Finally, we were interested in analyzing, for those cases where more than one previous commit exist, how many of them introduced the bug in the code source. Even if several previous commits are involved, it may be the case that none, at least one of them or all of them is the cause of the bug.

Results are given in Table~\ref{tab:secondStage3}; in 16 bug reports all the previous commits were identified as the cause, in 33 bug reports at least one of the previous commits caused the bug, and in 12 bug reports none of the previous commits introduced the bug. If we look at bugs that had two previous commits, in 9 cases both commits were the cause, in 13 cases only one of them was the cause and in another 5 cases non of them could be determined as the cause.

%\grex{Entiendo el resultado del parrafo anterior, pero me falta una explicacion de por que esto es interesante y para que puede servir.}\gema{Para entender como de complejo es el problema, porque no es lo mismo que dos commits anteriores sean responsables a que lo sean 5, entendiendo que si son cambios independientes es muy raro que sean causantes de un mismo error. y para saber si algun patron se repite y nos ayuda a entender algo, pero las tablas no llegan a ser muy concluyentes y los numeros son bajos, podemos introducirlo como un poco de discusion sobre que podria ser interesante analizar mas y ver si con mas poblacion se repite algun patron y decir exactamente cuantos comits son los responsables en un bug report.}

\begin{table*}[htb]
\begin{center} {\footnotesize
\begin{tabular}{lccccc}
\toprule[0.3mm]
   & \multicolumn{1}{c}{two previous} & \multicolumn{1}{c}{three previous} & \multicolumn{1}{c}{four previous} & \multicolumn{1}{c}{+four previous} & \multicolumn{1}{c}{Total}\\
  & \multicolumn{1}{c}{commits} & \multicolumn{1}{c}{commits}& \multicolumn{1}{c}{commits}& \multicolumn{1}{c}{commits}\\\hline
\raisebox{1ex}{One are the cause}        & 13& 1 & 1 & 4 & 19\\[0ex]
\raisebox{1ex}{Two are the cause}        & 9 & 7 & 3 & 1 & 20\\[0ex]
\raisebox{1ex}{Three are the cause}      & - & 4 & 0 & 2 & 6\\[0ex]
\raisebox{1ex}{Four are the cause}       & - & - & 0 & 1 & 1\\[0ex]
\raisebox{1ex}{+Four are the cause}      & - & - & - & 3 & 3\\[0ex]
\raisebox{1ex}{None is the cause}        & 5 & 3 & 3 & 1 & 12\\[0ex]
\raisebox{1ex}{Undecided}                & 1 & 0 & 1 & 0 & 2\\[0ex]
\bottomrule[0.3mm]
\end{tabular} }
\caption{Number of previous commits identified as the cause of a bug per bug report}
\label{tab:secondStage3}
\end{center}
\end{table*}

\vspace{0.2cm}
\fbox{\begin{minipage}{25em}
\textbf{RQ2: Only 50\% of the previous commits analyzed caused the failure in the system, whereas the 37\% of them did not introduce the bug in the code source.} 
\end{minipage}}
\vspace{0.1cm}


\section{Discussion}
\label{sec:discussion}

The identification of an issue as a bug report is a process that is not as straightforward as one might think. Out of 459 tickets we were only capable to achieve a consensus for 292 cases (63.6\%), which hints to the difficulty of the task. Tom help the humans taking the decisions, we investing in building a tool to assist them, by presenting all the relevant information, coming from different data sources, in an easy way. That helped to make the process smoother, but still the differences in judgment, with the same information available, persisted.

After analyzing several hundreds of bugs in this study, we have realized as well that determining where and when a bug was introduced in not a trivial task. In fact, even just determining if the bug was present at the time a certain commit introduced the code that latter triggered it is in some cases not easy.

For example, we have found many cases where we have been unable to determine the point of introduction of the bug, as no previous commit can be identified. One of those cases is when the fix only adds code: in such case there is no way of identifying the previous commit as we defined it, since there is no previous commit touching the fixing lines. In this case, only further research could find out if the code surrounding the added lines was responsible for the bug, or maybe some other part of the code.

%And we are talking about a bug report not a new feature, these kinds of cases use to be when a researcher forgot check some case inside a function.
%\begin{enumerate}
%\item Is responsible the function where these lines are content?
%\item Is responsible the last commit that modify something in the function?
%\end{enumerate}

%\grex{Puedes elaborar un poco mas el parrafo (y los puntos) anterior(es)? Puede ser en castellano.}
%\gema{En casos de que el error se arregle solamente anadiendo lineas, al intentar saber quien es el causante, podemos pensar en que el responsable podria ser el primero que introduce la funcion que olvido tener en cuenta ese caso, o si la funcion en la que se anade el codigo ha sido modificada varias veces pordriamos pensar que el ultimo que modifico la funcion puede ser el causante porue no se dio cuenta que fataba por anadir ese codigo.}

%\gema{Otro caso puede ser lo if/else, en estos casos hay que ser cuidadosos y saber diferenciar si el causante fue el comit previo porque se olvido de comporbar una condicion, o si el commit previo no fue el causante del error porque la condicion que se introduce en el commit que arregla el error se debe a que han anadido una nueva funcionalidad despues de haber anadido el if/else y necesitan comprobarla ahora, por tanto seria debido a la evolucion del projecto. En este ultimo caso, si no tenemos toda la descripcion de lo que realmente esta pasando, para poder decidir en que situacion estamos, hemos sido conservadores y hemos inducado que el commit anterior fue el responsable}

Another case is when additional conditions are added to \emph{if} or \emph{else} clauses. One might think that in the previous commit those were not included due to an error, so that the previous commit is the cause of the bug. However, situations exist where the need for additional code in an \emph{if} clause appear because of the later introduction of some new functionality, and thus the line in the previous commit was correct at the time it was introduced. In our analysis, if the latter situation is not explicitly mentioned we have considered that the previous commit caused the error.

%\begin{enumerate}
% \item No todos los casos son tan claros como los mostrados en los ejemplos, hay ocasiones en las que solo se ha anadido codigo y no somos capaces de encontrar al responsable por que no existe ninguna manera de poder identificar al commit previo. 
% \item Hemos sido conservadores, en ocasiones cuando se han modificado lineas como if/else y se han anadido comprobacione que anteriormente no estaban, se puede pensar que el commit previo que toco la linea se olvido de realizar dichas comporbaciones, y en ese caso seria el causante del bug. Pero existen casos que la comprobacion que se necesita en el if ha aparecido porque se introdujo una nueva funcionalidad, por stanto en el momento original en el que se escribio la linea por primera vez no habia ningun error. Por tanto a menos que se descrisba esta ultima situacion en la descripcion del commit o del bug report, he considerado la idea treadicional, que el commit anterior provoco el error, porque realmente era dificil saberlo.
% \item Hemos utilizado la herramienta porque es un proceso complicado. Para la primera parte de decidir si es o no es un bug report hemos tenido que desarrollar la herramienta.
%\end{enumerate}

In studies such as Kim et al.~\cite{kim2006automatic} and Williams et al.~\cite{williams2008szz} also manually analyzed samples of SZZ data. However, they report much higher percentages of correct SZZ results than in this study. The reason could be linked to the time spent in the manual verification (40 seconds in mean), which was lower than us, so they maybe didn't entered into details as much as we have did. Whereas we have analyzed the whole context of a bug-fix they only focused in verify the bug-fix hunks, thus they could omit changes in the API or changes due to the evolution of the code. In the other hand, Williams et al.~\cite{williams2008szz} only took 25 random bug fix commits to manually analyze, and probably it was a small size population. Of course, it could also be because of the specific projects selected in the studies, which could lead to very different cases of bug introduction by previous commits. This is one of the reasons we propose further work to extend our analysis to a varied set of projects.

In any case, our research shows evidence that assuming that the previous commit is where the cause of a bug can be found does not hold for a significant fraction of bugs. The most common reasons for the previous commit not introducing the bug are:

\begin{itemize}
  \item Changes to APIs, such as the addition of an argument.
  \item Variable renaming.
  \item Changes in the operating system, packages or requirements.
  \item Optimization of the code in some lines.
  \item Grammar errors, dragged from former commits. 
\end{itemize}
 

%\gema{En la discussion podemos poner tambien una pequeña lista con los casos mas repetidos en los que el commit previo no es responsable: He revisado esos casos y he obtenido la siguiente lista:
%- Cambios en la APi\\
%- Cambios en el nombre de una variable\\
%- Cambios en el formato, pero no son FP, si no que despues del cambio la funcion hace lo mismo que antes, por ejemplo guardan valores de retorno de funciones en variables y usan esa variable en vez de la llamada de la función directamente, o \\
%- Lineas eliminando 'imports' que no se usan \\
%- Evolución del lenguaje ó código ya que antes no podía soportar ciertas cosas como por ejemplo traducciones y ahora si, por tanto los tickets hablan de fallos en la traduccion y en realidad no habia traduccion porque probablemente en el momento de insertar el código no se soportaba. \\
%- Errores gramaticales arrastrados de commit previos.
%- Actualizaciones de SO, requisitos, etc.
%}


\section{Threats to validity}
\label{sec:threats}


%The limited sample size of tickets used in this research is the major threat to its validity. %It may happen, that only with 100 seemingly random tickets, there may be a prior unknown tendency. This is in fact similar to~\cite{sliwerski2005changes}, where the trend indicates that most bugs are fixed on Fridays.
The main threat to validity is the number of tickets considered. It is relatively high, but there is a long way to get a representative sample from a variety of free/open source systems, or software projects at large. Our analysis requires a lot of human effort, so increasing meaningfully the number of tickets is difficult. However, it should be noted that our numbers are the order of magnitude of similar studies: for instance Hindle's et al. article on large commits, considered 100~\cite{hindle2008large} commits.

Other internal threats to validity are:

\begin{itemize}
  \item We have not considered those tickets where the two researchers showed discordance. 
%  \begin{enumerate}
%    \item Should they discuss after their analysis to reach a better classification?, Should the tool provide this?
%    \item Does the Bug report only the same ticket classified as Bug report for all the researchers?
%  \end{enumerate}
    \item We have not taken into account errors that have been classified into \textit{Undecided}, and probably we have lost some \emph{actual} bug reports.
    \item There could be some lax criteria involving the subjective opinion of the researchers.
    \item Although the researchers are experienced programmers, they are not experts in the  OpenStack project, and their inexperience may have influenced the results of the analysis.
    \item We are only using part of the information that the tickets provide, like comments and text. There could be some patterns that can be found in other parts of the information.
    \item We have used a random script to extract the tickets from Launchpad that have been reported during 2015. There could be unintended bias of the data, because many reasons, as for instance the phase of the project.
    \item In some cases, researchers may have classified the previous commit as the cause of the bug, even if this may not be the case (see discussion on additional conditions in if statements).
\end{itemize}

The most important external threats, most of them related to peculiarities of the OpenStack project, are:

\begin{itemize}
    \item The word \textit{bug} is continuously mentioned in the description of commits and tickets, even when it is not an error. This could lead to the incorrect classification during the reviewing process.
    \item Some tickets are not explicitly described, which could increase the percentage of \textit{Undecided}. This is especially true if the reviewers are not from OpenStack.
    \item OpenStack is a special project with a very rapid evolution, and a very active community of developers. Maybe, in other projects with less commits per year, results may be totally different.
\end{itemize}

\section{Conclusions and Future Work}
\label{sec:conclusions}

The empirical experiment we have performed in OpenStack has shown that the previous change in the lines touched to fix a bug didn't introduce it for a large fraction of the analyzed bugs: about 37\% of the previous commits were not the cause of the bug.

In many cases, we have identified which ones are the changes that actually introduced the bug, which could be useful to improve the accuracy of tools and models developed to prevent bugs. Also, software developers can benefit from identifying where the bug was inserted, improving their processes.
%How to plan to apply the knowledge in a way that can benefit software engineers.
%What are the anticipated contributions of the work?  How will you evaluate them to demonstrate usefulness?


%\gema{Debemos añadir a trabajo futuro algo de esto: "Further analysis or reasoning about which types of bugs were mischaracterized by SZZ and why that happened is also missing from the paper, because of which the implications of the study is not clear."}
%\gema{Podemos añadir a trabajo futuro que nos gustaria entender porque ciertos de los cambios que no son causados por commit previos, como los de las API, no son capturados en los ficheros de tests y de que forma podríamos mitigar los bugs insertados tanto en commit previos como no}

%\gema{Otra cosa que tenemos que mencionar en el paper de acuerdo con los revisores: "it is unclear how the community can move forward from here? Since abandoning SZZ altogether is unreasonable (without proposing an alternative), can you offer advice based on findings that would help to improve SZZ? For example, an analysis of the bug fixes that mistakenly blame the previous version of those lines would likely shed some light onto how SZZ could be improved"}

Once we have found that at least in OpenStack the previous commit is in many cases not responsible for introducing a bug, it makes sense to explore, as future work, to which extent this happens in other projects. In particular, OpenStack is a project written mostly in Python, and very active, adding new functionality at a high pace. From the language point of view, it would be interesting studying projects less flexible about types and parameters in API calls, since changes in the API could be in those cases caught by the compiler, and don't become bugs. This is important because in OpenStack many cases of bugs not introduced by the previous commits were because of changes in APIs. With respect to activity, continuous changes in functionality may cause that many bugs are introduced by changes to the code that are not reflected in other parts that use it, leading to most cases of bugs not introduced by the previous commit.

Of course, another future line is the classification, in different projects, of all the cases of introduction of bugs that are not related to the previous commit. This could help to better designing integration tests, to better check for those cases.

The full automation of the methodology used in this paper is also interesting from a practical point of view. That would provide software projects with a valuable tool for understanding how they are introducing bugs, and therefore design measures for mitigation.

\textbf{Replication package}: we have set up a replication package\footnote{\url{http://gemarodri.github.io/2016-ICSME-prevcommit/}} including data sources, intermediate data and scripts.

%ACKNOWLEDGMENTS are optional
\section{Acknowledgments}

We thank Dorealda Dalipaj and Nelson Sekitoleko, two PhD students in our research team, for their participation in the process of classifying bug reports. We also want to express our gratitude to Bitergia\footnote{\url{http://bitergia.com/}} for the OpenStack database and the support they have provided when questions have arisen. Finally, we acknowledge the Spanish Government, because all authors are funded in part by it, through project TIN2014-59400-R.

\newpage
%\nocite{*}
%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{sigproc}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
%APPENDICES are optional
%\balancecolumns
\end{document}
